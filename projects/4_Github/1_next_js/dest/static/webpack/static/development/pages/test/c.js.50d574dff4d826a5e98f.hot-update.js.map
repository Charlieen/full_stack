{"version":3,"file":"static/webpack/static/development/pages/test/c.js.50d574dff4d826a5e98f.hot-update.js","sources":["webpack:///./pages/test/c.js"],"sourcesContent":["import React,{useState ,useReducer,useContext,\n    useLayoutEffect,useEffect ,useRef, memo,useMemo,useCallback} from 'react'\n\nimport MyContext from '../../lib/my-context'\n\nfunction countReducer(state,action){\n    switch (action.type) {\n        case 'add':\n            return state+1\n            \n        case 'minus':\n            return state-1\n    \n        default:\n            return state;\n    }\n}\n/**\n *  函数式组件，在每次被 虚拟DOM 要求刷新时，如果 函数式组件 内部的 对象 或者 函数 都会 重新生成 新的，\n *  1. \n */\nfunction MyCountFunc(){\n    const [count,dispatchCount]= useReducer(countReducer,0)\n    const [name,setName] = useState('charlie')\n// 每一次 MyCountFunc 组件 刷新，该config 都会重新生成新的对象，\n    const config = useMemo(()=>({\n        text:`count is ${count}`,\n        color:count>3? 'red':'blue',\n    }),[count])\n\n    // 每一次 MyCountFunc 组件 刷新，()=>dispatchCount({type:'add'}) 都会重新生成新的匿名函数，\n\n    const handleButtonClick = useCallback(()=>dispatchCount({type:'add'})\n    ,[dispatchCount])\n    return (\n        <div>\n            <input  value={name} onChange={(e)=>setName(e.target.value)}/>\n            <Child\n              config={config}\n              onButtonClick={ handleButtonClick}\n            />\n        </div>\n    )\n}\n\nconst Child = memo( function Child({onButtonClick,config}) {\n    console.log('child render')\n    return (\n        <button onClick={onButtonClick} style={{ color:config.color}}>\n        {config.text}\n        </button>\n    )\n})\nexport default MyCountFunc"],"mappings":";;;;;;;;;;;;;;;;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAFA;AAAA;AACA;AAMA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;;;;A","sourceRoot":""}